
const mongoose = require('mongoose');




const attendanceMasterSchema = new mongoose.Schema({
    empId: {
        type: String,
        required: true,
        unique: true,
        trim: true
    },
    employeeId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Employee",
        required: true
    },
    employeeName: {
        type: String,
        required: true,
        trim: true
    },
    department: {
        type: String,
        required: true,
        trim: true
    },
    shift: {
        type: {
            type: String,
            enum: ['Morning', 'Evening', 'Night', 'Flexible'],
            required: true,
            default: 'Morning'
        },
        startTime: {
            type: String,
            required: true,
            default: '10:00' // Format: "HH:MM"
        },
        endTime: {
            type: String,
            required: true,
            default: '18:00' // Format: "HH:MM"
        },
        breakDuration: {
            type: Number,
            default: 60 // in minutes
        }
    },
    workingDaysPerMonth: {
        type: Number,
        default: 26,
        min: 1,
        max: 31
    },
    weeklyOffDays: [{
        type: String,
        enum: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
        default: ['Saturday', 'Sunday']
    }],
    gracePeriod: {
        type: Number,
        default: 15, // minutes
        min: 0,
        max: 60
    },
    overtimeRate: {
        type: Number,
        default: 1.5, // multiplier
        min: 1.0,
        max: 3.0
    },
    paidLeaveAllowance: {
        type: Number,
        default: 2, // 2 paid leave days per month
        min: 0,
        max: 10
    },
    paidLeaveUsed: {
        type: Number,
        default: 0,
        min: 0
    },
    isActive: {
        type: Boolean,
        default: true
    },
    createdAt: {
        type: Date,
        default: Date.now
    },
    updatedAt: {
        type: Date,
        default: Date.now
    }
}, {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// Add this static method to the AttendanceMaster model
attendanceMasterSchema.statics.processDailyAttendance = async function(date) {
  const targetDate = date ? new Date(date) : new Date();
  targetDate.setHours(0, 0, 0, 0);
  
  const masters = await this.find({ isActive: true }).lean();
  const updates = [];
  
  for (const master of masters) {
    // Check if it's a working day
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const dayName = dayNames[targetDate.getDay()];
    const isWorkingDay = !master.weeklyOffDays.includes(dayName);
    
    if (!isWorkingDay) continue;
    
    // Check if attendance record already exists
    const existingRecord = await AttendanceRecord.findOne({
      employeeId: master.employeeId,
      date: {
        $gte: new Date(targetDate.setHours(0,0,0,0)),
        $lt: new Date(targetDate.setHours(23,59,59,999))
      }
    });
    
    if (!existingRecord) {
      // Create absent record
      updates.push({
        employeeId: master.employeeId,
        empId: master.empId,
        employeeName: master.employeeName,
        date: targetDate,
        status: 'absent',
        autoGenerated: true,
        approved: true
      });
    }
  }
  
  // Bulk insert missing attendance records
  let recordsCreated = 0;
  if (updates.length > 0) {
    await AttendanceRecord.insertMany(updates);
    recordsCreated = updates.length;
  }
  
  return { recordsCreated };
};

// Indexes for better performance
attendanceMasterSchema.index({ empId: 1, isActive: 1 });
attendanceMasterSchema.index({ employeeId: 1, isActive: 1 });
attendanceMasterSchema.index({ department: 1, isActive: 1 });

// Virtual for remaining paid leave days
attendanceMasterSchema.virtual('remainingPaidLeave').get(function() {
    return Math.max(0, this.paidLeaveAllowance - this.paidLeaveUsed);
});

// Virtual for shift duration in hours
attendanceMasterSchema.virtual('shiftDurationHours').get(function() {
    if (!this.shift.startTime || !this.shift.endTime) return 0;
    
    const [startHour, startMinute] = this.shift.startTime.split(':').map(Number);
    const [endHour, endMinute] = this.shift.endTime.split(':').map(Number);
    
    const startMinutes = startHour * 60 + startMinute;
    const endMinutes = endHour * 60 + endMinute;
    
    let duration = endMinutes - startMinutes;
    if (duration < 0) duration += 24 * 60; // Handle overnight shifts
    
    return (duration - this.shift.breakDuration) / 60; // Convert to hours, subtract break
});

// Virtual for weekly working days
attendanceMasterSchema.virtual('weeklyWorkingDays').get(function() {
    return 7 - (this.weeklyOffDays ? this.weeklyOffDays.length : 2);
});

// Static method to find by employee ID
attendanceMasterSchema.statics.findByEmployeeId = function(employeeId) {
    return this.findOne({ employeeId, isActive: true });
};

// Static method to find by employee empId
attendanceMasterSchema.statics.findByEmpId = function(empId) {
    return this.findOne({ empId, isActive: true });
};

// Static method to get all active masters
attendanceMasterSchema.statics.findAllActive = function() {
    return this.find({ isActive: true }).populate('employeeId', 'name empId designation department');
};

// Static method to get masters by department
attendanceMasterSchema.statics.findByDepartment = function(department) {
    return this.find({ department, isActive: true }).populate('employeeId', 'name empId designation department');
};

// Instance method to update paid leave used
attendanceMasterSchema.methods.updatePaidLeaveUsed = async function() {
    const AttendanceRecord = require('./AttendanceRecord');
    
    // Get current month's start and end dates
    const now = new Date();
    const startDate = new Date(now.getFullYear(), now.getMonth(), 1);
    const endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    
    // Count paid leave days used this month
    const paidLeaves = await AttendanceRecord.countDocuments({
        employeeId: this.employeeId,
        date: { $gte: startDate, $lte: endDate },
        status: "leave",
        leaveType: "paid",
        approved: true
    });
    
    this.paidLeaveUsed = paidLeaves;
    await this.save();
    
    return this.paidLeaveUsed;
};

// Instance method to check if employee can take paid leave
attendanceMasterSchema.methods.canTakePaidLeave = function() {
    return this.paidLeaveUsed < this.paidLeaveAllowance;
};

// Instance method to get shift details
attendanceMasterSchema.methods.getShiftDetails = function() {
    return {
        type: this.shift.type,
        startTime: this.shift.startTime,
        endTime: this.shift.endTime,
        breakDuration: this.shift.breakDuration,
        duration: this.shiftDurationHours,
        gracePeriod: this.gracePeriod
    };
};

// Instance method to check if a day is working day
attendanceMasterSchema.methods.isWorkingDay = function(date) {
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const dayName = dayNames[date.getDay()];
    return !this.weeklyOffDays.includes(dayName);
};

// Instance method to get next working day
attendanceMasterSchema.methods.getNextWorkingDay = function(fromDate) {
    const nextDay = new Date(fromDate);
    do {
        nextDay.setDate(nextDay.getDate() + 1);
    } while (!this.isWorkingDay(nextDay));
    return nextDay;
};

// Instance method to calculate overtime pay
attendanceMasterSchema.methods.calculateOvertimePay = function(overtimeMinutes, hourlyRate) {
    const overtimeHours = overtimeMinutes / 60;
    return overtimeHours * hourlyRate * this.overtimeRate;
};

// Instance method to reset monthly data (call at start of each month)
attendanceMasterSchema.methods.resetMonthlyData = function() {
    this.paidLeaveUsed = 0;
    this.updatedAt = new Date();
    return this.save();
};

// Pre-save middleware to update timestamps
attendanceMasterSchema.pre('save', function(next) {
    this.updatedAt = new Date();
    
    // Validate shift times
    if (this.shift && this.shift.startTime && this.shift.endTime) {
        const timePattern = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
        if (!timePattern.test(this.shift.startTime) || !timePattern.test(this.shift.endTime)) {
            return next(new Error('Invalid time format. Use HH:MM format.'));
        }
    }
    
    // Ensure paid leave used doesn't exceed allowance
    if (this.paidLeaveUsed > this.paidLeaveAllowance) {
        this.paidLeaveUsed = this.paidLeaveAllowance;
    }
    
    next();
});

// Pre-remove middleware to handle soft delete
attendanceMasterSchema.pre('remove', function(next) {
    // Instead of actual removal, deactivate
    this.isActive = false;
    this.save().then(() => next()).catch(next);
});

// Static method to bulk create or update masters
attendanceMasterSchema.statics.bulkCreateOrUpdate = async function(mastersData) {
    const results = {
        created: 0,
        updated: 0,
        errors: []
    };
    
    for (const masterData of mastersData) {
        try {
            const existing = await this.findOne({ empId: masterData.empId });
            
            if (existing) {
                // Update existing
                Object.assign(existing, masterData);
                existing.isActive = true;
                await existing.save();
                results.updated++;
            } else {
                // Create new
                const newMaster = new this(masterData);
                await newMaster.save();
                results.created++;
            }
        } catch (error) {
            results.errors.push({
                empId: masterData.empId,
                error: error.message
            });
        }
    }
    
    return results;
};

// Static method to get attendance statistics
attendanceMasterSchema.statics.getAttendanceStats = async function() {
    const totalMasters = await this.countDocuments({ isActive: true });
    const departmentStats = await this.aggregate([
        { $match: { isActive: true } },
        { $group: { _id: '$department', count: { $sum: 1 } } },
        { $sort: { count: -1 } }
    ]);
    
    const shiftStats = await this.aggregate([
        { $match: { isActive: true } },
        { $group: { _id: '$shift.type', count: { $sum: 1 } } },
        { $sort: { count: -1 } }
    ]);
    
    return {
        totalMasters,
        departmentStats,
        shiftStats
    };
};

module.exports = mongoose.models.AttendanceMaster || mongoose.model("AttendanceMaster", attendanceMasterSchema);